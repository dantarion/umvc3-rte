const fs = require('fs')
const path = require('path')
const assert = require('assert')

const common = require('./common')
const _ = require('struct-fu')
const mkdirp = require('mkdirp')
const escodegen = require('escodegen')
const esprima = require('esprima')
const printf = require('printf')
const AnmEntryHeader = _.struct([_.uint32le('functionCount'), _.uint32le('unknown2'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmFunctionHeader = _.struct([_.int32le('frame'), _.uint32le('offset')])
const AnmFunctionHeader2 = _.struct([_.int32le('frame'), _.uint32le('commandCount'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmCommand = _.struct([_.uint32le('group'), _.uint32le('id'), _.uint32le('dataCount'), _.uint32le('unknown4')])
function unpackAnm (buffer, folder) {
  const astRoot = {
    type: 'Program',
    body: [],
    sourceType: 'script',
    leadingComments: [
      {
        type: 'Line',
        value: ' Generated by umvc3.js (http://github/dantarion/umvc3.js)',
        range: [0, 59]
      }
    ]
  }
  // Read Header
  const entryHeader = common.CommonHeaderStruct.unpack(buffer, 0)
  const entries = {}
  assert(entryHeader.Type === 'CAC', 'This isn\'t a proper .anm file, missing header CAC')
  assert(entryHeader.unknown === 1195287387, 'Is this really constant? unknown')
  assert(entryHeader.unknown2 === 0, 'Is this really constant? unknown2')
  // console.log(entryHeader)
  // entryHeader.tableCount = 10;
  for (let i = 0; i < entryHeader.tableCount; i++) {
    const tableEntry = common.CommonTableEntry.unpack(buffer.slice(0x10 + i * 8))
    const astFunction = {
      type: 'FunctionDeclaration',
      id: {
        type: 'Identifier',
        name: printf('state%03X', tableEntry.id)
      },
      params: [],
      body: {
        type: 'BlockStatement',
        body: []
      },
      generator: false,
      expression: false,
      leadingComments: [
        {
          type: 'Line',
          value: printf("0x%X", tableEntry.offset),
          range: [0, 59]
        }
      ]
    }
    astRoot.body.push(astFunction)

    const anmHeader = AnmEntryHeader.unpack(buffer.slice(tableEntry.offset))
    assert(anmHeader.unknown3 === 0, 'Is this really constant? unknown3')
    assert(anmHeader.unknown4 === 0, 'Is this really constant? unknown4')
    // console.log('\t', anmHeader)
    for (let j = 0; j < anmHeader.functionCount + 1; j++) {
      // Read Function Header
      const functionHeader = AnmFunctionHeader.unpack(buffer.slice(tableEntry.offset + 0x10 + j * 8))
      // console.log('\t\t', functionHeader)
      const astLabel = {
        type: 'LabeledStatement',
        label: {
          type: 'Identifier',
          name: functionHeader.frame === -1
            ? 'init'
            : printf('frame_%d', functionHeader.frame)
        },
        body: {
          type: 'BlockStatement',
          body: []
        }
      }
      astFunction.body.body.push(astLabel)
      const secondaryData = AnmFunctionHeader2.unpack(buffer.slice(tableEntry.offset + functionHeader.offset))
      // console.log('\t\t', secondaryData)
      assert(secondaryData.unknown3 === 0, 'Is this really constant? unknown3')
      assert(secondaryData.unknown4 === 0, 'Is this really constant? unknown4')
      for (let n = 0; n < secondaryData.commandCount; n++) {
        const data = _.struct([_.int32le('offset'), _.uint32le('unknown1')]).unpack(buffer.slice(tableEntry.offset + functionHeader.offset + 0x10 + n * 8))

        const command = AnmCommand.unpack(buffer.slice(tableEntry.offset + functionHeader.offset + data.offset))
        // console.log('\t\t\t', command)
        var astCall = {
          type: 'ExpressionStatement',
          expression: {
            type: 'CallExpression',
            callee: {
              type: 'Identifier',
              name: printf('_%02X_%02X', command.group, command.id)
            },
            arguments: []
          },
          leadingComments: [
            {
              type: 'Line',
              value: printf("0x%X", tableEntry.offset + functionHeader.offset + data.offset),
              range: [0, 59]
            }
          ]


        }
        astLabel.body.body.push(astCall)
        if (command.dataCount > 0) {
          var params = _.uint32le(command.dataCount * 2).unpack(buffer.slice(tableEntry.offset + functionHeader.offset + data.offset + 0x10))
          var astParams = params.map((param) => {
            return {
              'type': 'Literal',
              'value': param,
              'raw': {
                content: printf('0x%X', param),
                precedence: escodegen.Precedence.Primary
              }
            }
          })
          astCall.expression.arguments = astParams
        }
      }
    }
  }
  const codeStr = escodegen.generate(astRoot, {
    format: {
      indent: {
        style: '  '
      }
    },
    comment: true,
    verbatim: 'raw'
  })
  // Prepare output folder
  mkdirp.sync(path.join(process.cwd(), 'working', folder))
  const outJS = fs.openSync(path.join(process.cwd(), 'working', folder, 'anmcmd.js'), 'w')
  fs.appendFileSync(outJS, codeStr)
  fs.closeSync(outJS)
  return entries
}
function unpackAnmFile (filename, folder) {
  let buffer
  try {
    buffer = fs.readFileSync(filename)
  } catch (e) {
    console.error('Error Opening', filename)
    throw e
  }
  return unpackAnm(buffer, folder)
}
function packAnm (filename, folder) {
  var outAnm = fs.openSync(filename, 'w')

  var entries = []
  var entrySizes = []

  var currentFile = path.join(folder, 'anmcmd.js')
  var sourceJS = fs.readFileSync(currentFile, 'utf-8')
  var result = esprima.parse(sourceJS)
  try {
    var header = {
      Type: 'CAC',
      unknown: 1195287387,
      unknown2: 0,
      tableCount: result.body.length
    }
    var dataStart = 0x10 + 8 * header.tableCount
    // Actually write file now!
    var headerData = common.CommonHeaderStruct.pack(header)
    fs.writeSync(outAnm, headerData, 0, headerData.length, 0)
    var currentOffset = dataStart
    result.body.forEach((stateExpr, index) => {
      assert(stateExpr.type === 'FunctionDeclaration')
      assert(stateExpr.id.name.startsWith('state'))
      var state = {
        id: parseInt(stateExpr.id.name.substr(5), 16),
        offset: currentOffset
      }
      var anmentryheader = {
        functionCount: stateExpr.body.body.length - 1,
        unknown2: -1
      }
      var entryBase = currentOffset
      currentOffset += 0x10
      currentOffset += stateExpr.body.body.length * 8
      stateExpr.body.body.forEach((frameExpr, index) => {
        var frame = {
          frame: -1,
          commandCount: frameExpr.body.body.length,
          offset: 0xBBBBBBBB
        }
        assert(frameExpr.type === 'LabeledStatement')
        if (frameExpr.label.name === 'init') {
          frame.frame = -1
        } else if (frameExpr.label.name.startsWith('frame')) {
          frame.frame = parseInt(frameExpr.label.name.substr(6), 10)
        } else {
          throw new Error('Labels can be either be "init" or "frame_%d"')
        }
        anmentryheader.unknown2 = Math.max(anmentryheader.unknown2, frame.frame)
        frame.offset = currentOffset - state.offset
        rawData = AnmFunctionHeader2.pack(frame)
        fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
        currentOffset += rawData.length
        var baseOffset = currentOffset
        currentOffset += 8 * frameExpr.body.body.length
        frameExpr.body.body.forEach((callExpr, index) => {
          assert(callExpr.type === 'ExpressionStatement')
          assert(callExpr.expression.type === 'CallExpression')
          var call = {
            group: 0,
            id: 0,
            dataCount: callExpr.expression.arguments.length / 2
          }
          call.group = parseInt(callExpr.expression.callee.name.substr(1, 2), 16)
          call.id = parseInt(callExpr.expression.callee.name.substr(4), 16)
          rawData = AnmCommand.pack(call)
          fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
          currentOffset += rawData.length

          rawData = _.uint32le(1).pack([currentOffset - baseOffset])
          fs.writeSync(outAnm, rawData, 0, rawData.length, baseOffset + 8 * index)

          callExpr.expression.arguments.forEach((argumentExpr) => {
            if (argumentExpr.type === 'Literal') {
              rawData = _.uint32le(1).pack([argumentExpr.value])
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            }
          })
        })
        rawData = AnmFunctionHeader.pack(frame)
        fs.writeSync(outAnm, rawData, 0, rawData.length, state.offset + 0x10 + 8 * index)
      })
      var rawData = AnmEntryHeader.pack(anmentryheader)
      fs.writeSync(outAnm, rawData, 0, rawData.length, entryBase)
      rawData = common.CommonTableEntry.pack(state)
      fs.writeSync(outAnm, rawData, 0, rawData.length, 0x10 + 8 * index)
    })
  } catch (e) {
    console.log('error on file:', currentFile)
    console.log(e)
  }
}
module.exports = {
  packAnm: packAnm,
  unpackAnmFile: unpackAnmFile,
  unpackAnm: unpackAnm
}
