const fs = require('fs')
const path = require('path')
const assert = require('assert')
const os = require('os')

const common = require('./common')
const _ = require('struct-fu')
const mkdirp = require('mkdirp')
const escodegen = require('escodegen')
const printf = require('printf')
const AnmEntryHeader = _.struct([_.uint32le('functionCount'), _.uint32le('unknown2'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmFunctionHeader = _.struct([_.int32le('frame'), _.uint32le('offset')])
const AnmFunctionHeader2 = _.struct([_.int32le('frame'), _.uint32le('commandCount'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmCommand = _.struct([_.uint32le('group'), _.uint32le('id'), _.uint32le('dataCount'), _.uint32le('unknown4')])
function unpackAnmEntry (buffer, folder) {}
function unpackAnm (buffer, folder) {

  const astRoot = {
    type: 'Program',
    body: [],
    sourceType: 'script',
    leadingComments: [
      {
        type: 'Line',
        value: ' Generated by umvc3.js (http://github/dantarion/umvc3.js)',
        range: [0, 59]
      }
    ]
  }
  // Read Header
  const entryHeader = common.CommonHeaderStruct.unpack(buffer, 0)
  const entries = {}
  assert(entryHeader.Type === 'CAC', 'This isn\'t a proper .anm file, missing header CAC')
  assert(entryHeader.unknown === 1195287387, 'Is this really constant? unknown')
  assert(entryHeader.unknown2 === 0, 'Is this really constant? unknown2')
  // console.log(entryHeader)
  // entryHeader.tableCount = 10;
  for (let i = 0; i < entryHeader.tableCount; i++) {
    const tableEntry = common.CommonTableEntry.unpack(buffer.slice(0x10 + i * 8))
    const astFunction = {
      type: 'FunctionDeclaration',
      id: {
        type: 'Identifier',
        name: printf('state%03X', tableEntry.id)
      },
      params: [],
      body: {
        type: 'BlockStatement',
        body: []
      },
      generator: false,
      expression: false
    }
    astRoot.body.push(astFunction)

    const anmHeader = AnmEntryHeader.unpack(buffer.slice(tableEntry.offset))
    assert(anmHeader.unknown3 === 0, 'Is this really constant? unknown3')
    assert(anmHeader.unknown4 === 0, 'Is this really constant? unknown4')
    // console.log('\t', anmHeader)
    for (let j = 0; j < anmHeader.functionCount + 1; j++) {
      // Read Function Header
      const functionHeader = AnmFunctionHeader.unpack(buffer.slice(tableEntry.offset + 0x10 + j * 8))
      // console.log('\t\t', functionHeader)
      const astLabel = {
        type: 'LabeledStatement',
        label: {
          type: 'Identifier',
          name: functionHeader.frame === -1
            ? 'init'
            : printf('frame_%d', functionHeader.frame)
        },
        body: {
          type: 'BlockStatement',
          body: []
        }
      }
      astFunction.body.body.push(astLabel)
      const secondaryData = AnmFunctionHeader2.unpack(buffer.slice(tableEntry.offset + functionHeader.offset))
      // console.log('\t\t', secondaryData)
      assert(secondaryData.unknown3 === 0, 'Is this really constant? unknown3')
      assert(secondaryData.unknown4 === 0, 'Is this really constant? unknown4')
      for (let n = 0; n < secondaryData.commandCount; n++) {
        const data = _.struct([_.int32le('offset'), _.uint32le('unknown1')]).unpack(buffer.slice(tableEntry.offset + functionHeader.offset + 0x10 + n * 8))

        const command = AnmCommand.unpack(buffer.slice(tableEntry.offset + functionHeader.offset + data.offset))
        // console.log('\t\t\t', command)
        var astCall = {
          type: 'ExpressionStatement',
          expression: {
            type: 'CallExpression',
            callee: {
              type: 'Identifier',
              name: printf('_%02X_%02X', command.group, command.id)
            },
            arguments: []
          }
        }
        astLabel.body.body.push(astCall)
        if (command.dataCount > 0) {
          var params = _.uint32le(command.dataCount * 2).unpack(buffer.slice(tableEntry.offset + functionHeader.offset + data.offset + 0x10))
          var astParams = params.map((param) => {
            return {
              'type': 'Literal',
              'value': param,
              'raw': {
                content: printf('0x%X', param),
                precedence: escodegen.Precedence.Primary
              }
            }
          })
          astCall.expression.arguments = astParams
        }
      }
    }
  }
  const codeStr = escodegen.generate(astRoot, {
    format: {
      indent: {
        style: '  '
      }
    },
    comment: true,
    verbatim: 'raw'
  })
  // Prepare output folder
  mkdirp.sync(path.join(__dirname, '..', 'working', folder))
  const outJS = fs.openSync(path.join(__dirname, '..', 'working', folder, 'anmcmd.js'), 'w')
  fs.appendFileSync(outJS, codeStr)
  fs.closeSync(outJS)
  return entries
}
function unpackAnmFile (filename, folder) {
  let buffer
  try {
    buffer = fs.readFileSync(filename)
  } catch (e) {
    console.error('Error Opening', filename)
    throw e
  }
  return unpackAnm(buffer, folder)
}
function packAnm (filename, folder) {
  throw new Error('packing an Anm from ')
}
fs.readdirSync(path.join(__dirname, '..', 'out', 'chr')).forEach((filename) => {
  console.log(filename)
  var filePath = path.join(__dirname, '..', 'out', 'chr', filename, 'anmchr.anm')
  try {
    unpackAnmFile(filePath, filename)
  } catch (e) {
    console.log('error', e)
  }
})
