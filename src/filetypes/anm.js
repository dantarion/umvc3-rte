const fs = require('fs')
const path = require('path')
const assert = require('assert')

const _ = require('struct-fu')
const mkdirp = require('mkdirp')
const escodegen = require('escodegen')
const esprima = require('esprima')
const printf = require('printf')

const common = require('./common')
const db = require('../commandDB.json')
const AnmEntryHeader = _.struct([_.uint32le('functionCount'), _.uint32le('unknown2'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmFunctionHeader = _.struct([_.int32le('frame'), _.uint32le('offset')])
const AnmFunctionHeader2 = _.struct([_.int32le('frame'), _.uint32le('commandCount'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmCommand = _.struct([_.uint32le('group'), _.uint32le('id'), _.uint32le('dataCount'), _.uint32le('unknown4')])
var usage = {}
function unpack (inBuffer, outFile) {
  const astRoot = {
    type: 'Program',
    body: [],
    sourceType: 'script',
    leadingComments: [
      {
        type: 'Line',
        value: ' Generated by umvc3.js (http://github/dantarion/umvc3.js)',
        range: [0, 59]
      }
    ]
  }
  // Read Header
  const entryHeader = common.CommonHeaderStruct.unpack(inBuffer, 0)
  const entries = {}
  assert(entryHeader.Type === 'CAC', 'This isn\'t a proper .anm file, missing header CAC')
  assert(entryHeader.unknown === 1195287387, 'Is this really constant? unknown')
  assert(entryHeader.unknown2 === 0, 'Is this really constant? unknown2')
  // console.log(entryHeader)
  // entryHeader.tableCount = 10;
  for (let i = 0; i < entryHeader.tableCount; i++) {
    const tableEntry = common.CommonTableEntry.unpack(inBuffer.slice(0x10 + i * 8))
    const tableEntryNext = common.CommonTableEntry.unpack(inBuffer.slice(0x10 + (i + 1) * 8))
    const anmHeader = AnmEntryHeader.unpack(inBuffer.slice(tableEntry.offset))
    assert(anmHeader.unknown3 === 0, 'Is this really constant? unknown3')
    assert(anmHeader.unknown4 === 0, 'Is this really constant? unknown4')

    const parentCall = {
      leadingComments: [
        {
          type: 'Line',
          value: printf('0x%X', tableEntry.offset)
        }
      ],
      'type': 'ExpressionStatement',
      'expression': {
        'type': 'CallExpression',
        'callee': {
          'type': 'Identifier',
          'name': 'defineState'
        },
        'arguments': [
          {
            'type': 'Literal',
            'value': tableEntry.id,
            'raw': printf('0x%03X', tableEntry.id)
          }, {
            'type': 'Literal',
            'value': anmHeader.unknown2
          }
        ]
      }
    }
    const astFunction = {
      type: 'FunctionDeclaration',
      id: null,
      params: [],
      body: {
        type: 'BlockStatement',
        body: []
      },
      generator: false,
      expression: false
    }
    parentCall.expression.arguments.push(astFunction)
    astRoot.body.push(parentCall)

    // console.log('\t', anmHeader)
    for (let j = 0; j < anmHeader.functionCount + 1; j++) {
      // Read Function Header
      const functionHeader = AnmFunctionHeader.unpack(inBuffer.slice(tableEntry.offset + 0x10 + j * 8))
      const functionHeaderNext = AnmFunctionHeader.unpack(inBuffer.slice(tableEntry.offset + 0x10 + (j + 1) * 8))
      // console.log('\t\t', functionHeader)
      const astLabel = {
        type: 'LabeledStatement',
        label: {
          type: 'Identifier',
          name: functionHeader.frame === -1
            ? 'init'
            : printf('frame_%d', functionHeader.frame)
        },
        body: {
          type: 'BlockStatement',
          body: []
        }
      }
      astFunction.body.body.push(astLabel)
      const secondaryData = AnmFunctionHeader2.unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset))
      // console.log('\t\t', secondaryData)
      assert(secondaryData.unknown3 === 0, 'Is this really constant? unknown3')
      assert(secondaryData.unknown4 === 0, 'Is this really constant? unknown4')
      for (let n = 0; n < secondaryData.commandCount; n++) {
        const data = _.struct([_.int32le('offset'), _.uint32le('unknown1')]).unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + 0x10 + n * 8))
        const data2 = _.struct([_.int32le('offset'), _.uint32le('unknown1')]).unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + 0x10 + (n + 1) * 8))
        var dataSize = data2.offset - data.offset - 0x10
        if (n === secondaryData.commandCount - 1) {
          dataSize = functionHeaderNext.offset - functionHeader.offset - data.offset - 0x10
          if (j === anmHeader.functionCount + 1 - 1) {
            dataSize = tableEntryNext.offset - functionHeader.offset - data.offset - 0x10
          }
        }
        const command = AnmCommand.unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + data.offset))
        // console.log('\t\t\t', command)
        var astCall = {
          type: 'ExpressionStatement',
          expression: {
            type: 'CallExpression',
            callee: {
              type: 'Identifier',
              name: printf('_%02X_%02X', command.group, command.id)
            },
            arguments: []
          },
          leadingComments: []
        }
        astLabel.body.body.push(astCall)
        var paramTypes = []
        var paramData = 0
        var paramEnd = tableEntry.offset + functionHeader.offset + data.offset + 0x10 + command.dataCount * 4

        if (command.dataCount > 0) {
          paramTypes = _.uint32le(command.dataCount).unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + data.offset + 0x10))
        }
        astCall.leadingComments[0] = {
          type: 'Line',
          value: JSON.stringify(paramTypes),
          range: [0, 59]
        }
        usage[astCall.expression.callee.name] = paramTypes
        var astParams = paramTypes.map((paramType, index) => {
          var retVal = -1
          if (paramType === 0x1) {
            retVal = _.int8(1).unpack(inBuffer.slice(paramEnd + paramData))[0]
            paramData += 1
            return {
              'type': 'Literal',
              'value': retVal,
              'raw': {
                content: retVal >= 0
                  ? printf('0x%X', retVal)
                  : printf('-0x%X', -retVal),
                precedence: escodegen.Precedence.Primary
              }
            }
          }
          if (paramType === 12) {
            retVal = _.float32le(3).unpack(inBuffer.slice(paramEnd + paramData))
            paramData += 12
            return {
              'type': 'ArrayExpression',
              'elements': retVal.map((val) => {
                return {
                  'type': 'Literal',
                  'value': val,
                  'raw': {
                    content: val >= 0
                      ? printf('%f', val)
                      : printf('-%f', -val),
                    precedence: escodegen.Precedence.Primary
                  }
                }
              })
            }
          }
          if (paramType === 13) {
            retVal = _.float32le(4).unpack(inBuffer.slice(paramEnd + paramData))
            paramData += 16
            return {
              'type': 'ArrayExpression',
              'elements': retVal.map((val) => {
                return {
                  'type': 'Literal',
                  'value': val,
                  'raw': {
                    content: val >= 0
                      ? printf('%f', val)
                      : printf('-%f', -val),
                    precedence: escodegen.Precedence.Primary
                  }
                }
              })
            }
          }
          if (paramType === 0x5) {
            retVal = _.int32le(1).unpack(inBuffer.slice(paramEnd + paramData))[0]
            paramData += 4
            return {
              'type': 'Literal',
              'value': retVal,
              'raw': {
                content: retVal >= 0
                  ? printf('0x%X', retVal)
                  : printf('-0x%X', -retVal),
                precedence: escodegen.Precedence.Primary
              }
            }
          }
          if (paramType === 6) {
            retVal = _.float32le(1).unpack(inBuffer.slice(paramEnd + paramData))[0]
            paramData += 4
            return {
              'type': 'Literal',
              'value': retVal,
              'raw': {
                content: printf('%f', retVal),
                precedence: escodegen.Precedence.Primary
              }
            }
          }
          if (paramType === 0x7) {
            retVal = _.char(64).unpack(inBuffer.slice(paramEnd + paramData))
            paramData += 64
            return {'type': 'Literal', 'value': retVal}
          }
          if (paramType === 0x10) {
            retVal = _.char(64).unpack(inBuffer.slice(paramEnd + paramData))
            paramData += 64
            return {'type': 'Literal', 'value': retVal}
          }
          retVal = _.uint32le(1).unpack(inBuffer.slice(paramEnd + paramData))[0]
          paramData += 4
          return {
            'type': 'Literal',
            'value': retVal,
            'raw': {
              content: printf('0x%X', retVal),
              precedence: escodegen.Precedence.Primary
            }
          }
        })
        astCall.expression.arguments = astParams
      }
    }
  }
  const codeStr = escodegen.generate(astRoot, {
    format: {
      indent: {
        style: '  '
      },
    },
    verbatim: 'raw',

  })
  // Prepare output folder
  mkdirp.sync(path.dirname(outFile))
  const outJS = fs.openSync(outFile, 'w')
  fs.appendFileSync(outJS, codeStr)
  fs.closeSync(outJS)
  return entries
}
function unpackFile (inFile, outFile) {
  let buffer
  try {
    buffer = fs.readFileSync(inFile)
  } catch (e) {
    console.error('Error Opening', inFile)
    throw e
  }
  return unpack(buffer, outFile)
}
function pack (inFile, outFile) {
  var outAnm = fs.openSync(outFile, 'w')

  var currentFile = inFile
  var sourceJS = fs.readFileSync(currentFile, 'utf-8')
  var result = esprima.parse(sourceJS)
  try {
    var header = {
      Type: 'CAC',
      unknown: 1195287387,
      unknown2: 0,
      tableCount: result.body.length
    }
    var dataStart = 0x10 + 8 * header.tableCount
    // Actually write file now!
    var headerData = common.CommonHeaderStruct.pack(header)
    fs.writeSync(outAnm, headerData, 0, headerData.length, 0)
    var currentOffset = dataStart
    result.body.forEach((expressExpression, index) => {
      assert(expressExpression.type === 'ExpressionStatement')
      var stateExpr = expressExpression.expression.arguments[2];
      assert(stateExpr.type === 'FunctionExpression')
      var state = {
        id: expressExpression.expression.arguments[0].value,
        offset: currentOffset
      }
      var anmentryheader = {
        functionCount: stateExpr.body.body.length - 1,
        unknown2: expressExpression.expression.arguments[1].value
      }
      var entryBase = currentOffset
      currentOffset += 0x10
      currentOffset += stateExpr.body.body.length * 8
      stateExpr.body.body.forEach((frameExpr, index) => {
        var frame = {
          frame: -1,
          commandCount: frameExpr.body.body.length,
          offset: 0xBBBBBBBB
        }
        assert(frameExpr.type === 'LabeledStatement')
        if (frameExpr.label.name === 'init') {
          frame.frame = -1
        } else if (frameExpr.label.name.startsWith('frame')) {
          frame.frame = parseInt(frameExpr.label.name.substr(6), 10)
        } else {
          throw new Error('Labels can be either be "init" or "frame_%d"')
        }

        frame.offset = currentOffset - state.offset
        rawData = AnmFunctionHeader2.pack(frame)
        fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
        currentOffset += rawData.length
        var baseOffset = currentOffset
        currentOffset += 8 * frameExpr.body.body.length
        frameExpr.body.body.forEach((callExpr, index) => {
          assert(callExpr.type === 'ExpressionStatement')
          assert(callExpr.expression.type === 'CallExpression')
          var call = {
            group: 0,
            id: 0,
            dataCount: callExpr.expression.arguments.length
          }

          call.group = parseInt(callExpr.expression.callee.name.substr(1, 2), 16)
          call.id = parseInt(callExpr.expression.callee.name.substr(4), 16)
          rawData = AnmCommand.pack(call)
          fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
          currentOffset += rawData.length

          rawData = _.uint32le(1).pack([currentOffset - baseOffset])
          fs.writeSync(outAnm, rawData, 0, rawData.length, baseOffset + 8 * index)

          var types = db[callExpr.expression.callee.name]
          rawData = _.uint32le(types.length).pack(types)
          fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
          currentOffset += rawData.length
          callExpr.expression.arguments.forEach((argumentExpr, index) => {
            var type = types[index]
            var val
            if (type === 6) {
              if (argumentExpr.type === 'UnaryExpression') {
                val = -argumentExpr.argument.value
              } else {
                val = argumentExpr.value
              }
              rawData = _.float32le(1).pack([val])
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else if (type === 0x1) {
              if (argumentExpr.type === 'UnaryExpression') {
                val = -argumentExpr.argument.value
              } else {
                val = argumentExpr.value
              }
              rawData = _.int8(1).pack([val])
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else if (type === 0x5) {
              if (argumentExpr.type === 'UnaryExpression') {
                val = -argumentExpr.argument.value
              } else {
                val = argumentExpr.value
              }
              rawData = _.int32le(1).pack([val])
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else if (type === 12) {
              var tmp = argumentExpr.elements.map((el) => {
                if (el.type === 'UnaryExpression') {
                  return -el.argument.value
                } else {
                  return el.value
                }
              })
              rawData = _.float32le(3).pack(tmp)
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else if (type === 13) {
              tmp = argumentExpr.elements.map((el) => {
                if (el.type === 'UnaryExpression') {
                  return -el.argument.value
                } else {
                  return el.value
                }
              })
              rawData = _.float32le(4).pack(tmp)
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else if (type === 0x7) {
              rawData = _.char(64).pack(argumentExpr.value)
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else if (type === 0x10) {
              rawData = _.char(64).pack(argumentExpr.value)
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            } else {
              if (argumentExpr.type === 'UnaryExpression') {
                val = -argumentExpr.argument.value
              } else {
                val = argumentExpr.value
              }
              rawData = _.uint32le(1).pack([val])
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            }
          })
        })
        rawData = AnmFunctionHeader.pack(frame)
        fs.writeSync(outAnm, rawData, 0, rawData.length, state.offset + 0x10 + 8 * index)
      })
      var rawData = AnmEntryHeader.pack(anmentryheader)
      fs.writeSync(outAnm, rawData, 0, rawData.length, entryBase)
      rawData = common.CommonTableEntry.pack(state)
      fs.writeSync(outAnm, rawData, 0, rawData.length, 0x10 + 8 * index)
    })
  } catch (e) {
    console.log('error on file:', currentFile)
    console.log(e)
  }
}
module.exports = {
  pack: pack,
  unpackFile: unpackFile,
  unpack: unpack,
  usage: usage
}
