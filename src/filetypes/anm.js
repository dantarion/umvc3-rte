const fs = require('fs')
const path = require('path')
const assert = require('assert')

const _ = require('struct-fu')
const mkdirp = require('mkdirp')
const escodegen = require('escodegen')
const esprima = require('esprima')
const printf = require('printf')

const common = require('./common')

const AnmEntryHeader = _.struct([_.uint32le('functionCount'), _.uint32le('unknown2'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmFunctionHeader = _.struct([_.int32le('frame'), _.uint32le('offset')])
const AnmFunctionHeader2 = _.struct([_.int32le('frame'), _.uint32le('commandCount'), _.uint32le('unknown3'), _.uint32le('unknown4')])
const AnmCommand = _.struct([_.uint32le('group'), _.uint32le('id'), _.uint32le('dataCount'), _.uint32le('unknown4')])

function unpack (inBuffer, outFile) {
  const astRoot = {
    type: 'Program',
    body: [],
    sourceType: 'script',
    leadingComments: [
      {
        type: 'Line',
        value: ' Generated by umvc3.js (http://github/dantarion/umvc3.js)',
        range: [0, 59]
      }
    ]
  }
  // Read Header
  const entryHeader = common.CommonHeaderStruct.unpack(inBuffer, 0)
  const entries = {}
  assert(entryHeader.Type === 'CAC', 'This isn\'t a proper .anm file, missing header CAC')
  assert(entryHeader.unknown === 1195287387, 'Is this really constant? unknown')
  assert(entryHeader.unknown2 === 0, 'Is this really constant? unknown2')
  // console.log(entryHeader)
  // entryHeader.tableCount = 10;
  for (let i = 0; i < entryHeader.tableCount; i++) {
    const tableEntry = common.CommonTableEntry.unpack(inBuffer.slice(0x10 + i * 8))
    const tableEntryNext = common.CommonTableEntry.unpack(inBuffer.slice(0x10 + (i + 1) * 8))
    const astFunction = {
      type: 'FunctionDeclaration',
      id: {
        type: 'Identifier',
        name: printf('state%03X', tableEntry.id)
      },
      params: [],
      body: {
        type: 'BlockStatement',
        body: []
      },
      generator: false,
      expression: false
    }
    astRoot.body.push(astFunction)

    const anmHeader = AnmEntryHeader.unpack(inBuffer.slice(tableEntry.offset))
    assert(anmHeader.unknown3 === 0, 'Is this really constant? unknown3')
    assert(anmHeader.unknown4 === 0, 'Is this really constant? unknown4')
    // console.log('\t', anmHeader)
    for (let j = 0; j < anmHeader.functionCount + 1; j++) {
      // Read Function Header
      const functionHeader = AnmFunctionHeader.unpack(inBuffer.slice(tableEntry.offset + 0x10 + j * 8))
      const functionHeaderNext = AnmFunctionHeader.unpack(inBuffer.slice(tableEntry.offset + 0x10 + (j + 1) * 8))
      // console.log('\t\t', functionHeader)
      const astLabel = {
        type: 'LabeledStatement',
        label: {
          type: 'Identifier',
          name: functionHeader.frame === -1
            ? 'init'
            : printf('frame_%d', functionHeader.frame)
        },
        body: {
          type: 'BlockStatement',
          body: []
        }
      }
      astFunction.body.body.push(astLabel)
      const secondaryData = AnmFunctionHeader2.unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset))
      // console.log('\t\t', secondaryData)
      assert(secondaryData.unknown3 === 0, 'Is this really constant? unknown3')
      assert(secondaryData.unknown4 === 0, 'Is this really constant? unknown4')
      for (let n = 0; n < secondaryData.commandCount; n++) {
        const data = _.struct([_.int32le('offset'), _.uint32le('unknown1')]).unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + 0x10 + n * 8))
        const data2 = _.struct([_.int32le('offset'), _.uint32le('unknown1')]).unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + 0x10 + (n + 1) * 8))
        var dataSize = data2.offset - data.offset - 0x10
        if (n === secondaryData.commandCount-1) {
          dataSize = functionHeaderNext.offset - functionHeader.offset - data.offset - 0x10
          if (j === anmHeader.functionCount + 1 - 1) {
            dataSize = tableEntryNext.offset - functionHeader.offset - data.offset - 0x10
          }
        }
        const command = AnmCommand.unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + data.offset))
        var hasStr = dataSize / command.dataCount !== 8
        // console.log('\t\t\t', command)
        var astCall = {
          type: 'ExpressionStatement',
          expression: {
            type: 'CallExpression',
            callee: {
              type: 'Identifier',
              name: printf('_%02X_%02X', command.group, command.id)
            },
            arguments: []
          },
          leadingComments: [
            {
              type: 'Line',
              value: printf('0x%X - %s', tableEntry.offset + functionHeader.offset + data.offset, JSON.stringify([dataSize.toString(16), hasStr, functionHeaderNext.offset.toString(16)])),
              range: [0, 59]
            }
          ]
        }
        astLabel.body.body.push(astCall)
        var params = []
        if (command.dataCount > 0) {
          params = _.uint32le(command.dataCount * 2).unpack(inBuffer.slice(tableEntry.offset + functionHeader.offset + data.offset + 0x10))
        }
        var astParams = params.map((param) => {
          if (typeof param === 'string') {
            return {
              'type': 'Literal',
              'value': param
            }
          } else {
            return {
              'type': 'Literal',
              'value': param,
              'raw': {
                content: printf('0x%X', param),
                precedence: escodegen.Precedence.Primary
              }
            }
          }
        })
        astCall.expression.arguments = astParams
      }
    }
  }
  const codeStr = escodegen.generate(astRoot, {
    format: {
      indent: {
        style: '  '
      }
    },
    comment: true,
    verbatim: 'raw'
  })
  // Prepare output folder
  mkdirp.sync(path.dirname(outFile))
  const outJS = fs.openSync(outFile, 'w')
  fs.appendFileSync(outJS, codeStr)
  fs.closeSync(outJS)
  return entries
}
function unpackFile (inFile, outFile) {
  let buffer
  try {
    buffer = fs.readFileSync(inFile)
  } catch (e) {
    console.error('Error Opening', inFile)
    throw e
  }
  return unpack(buffer, outFile)
}
function pack (inFile, outFile) {
  var outAnm = fs.openSync(outFile, 'w')

  var currentFile = inFile
  var sourceJS = fs.readFileSync(currentFile, 'utf-8')
  var result = esprima.parse(sourceJS)
  try {
    var header = {
      Type: 'CAC',
      unknown: 1195287387,
      unknown2: 0,
      tableCount: result.body.length
    }
    var dataStart = 0x10 + 8 * header.tableCount
    // Actually write file now!
    var headerData = common.CommonHeaderStruct.pack(header)
    fs.writeSync(outAnm, headerData, 0, headerData.length, 0)
    var currentOffset = dataStart
    result.body.forEach((stateExpr, index) => {
      assert(stateExpr.type === 'FunctionDeclaration')
      assert(stateExpr.id.name.startsWith('state'))
      var state = {
        id: parseInt(stateExpr.id.name.substr(5), 16),
        offset: currentOffset
      }
      var anmentryheader = {
        functionCount: stateExpr.body.body.length - 1,
        unknown2: -1
      }
      var entryBase = currentOffset
      currentOffset += 0x10
      currentOffset += stateExpr.body.body.length * 8
      stateExpr.body.body.forEach((frameExpr, index) => {
        var frame = {
          frame: -1,
          commandCount: frameExpr.body.body.length,
          offset: 0xBBBBBBBB
        }
        assert(frameExpr.type === 'LabeledStatement')
        if (frameExpr.label.name === 'init') {
          frame.frame = -1
        } else if (frameExpr.label.name.startsWith('frame')) {
          frame.frame = parseInt(frameExpr.label.name.substr(6), 10)
        } else {
          throw new Error('Labels can be either be "init" or "frame_%d"')
        }
        anmentryheader.unknown2 = Math.max(anmentryheader.unknown2, frame.frame)
        frame.offset = currentOffset - state.offset
        rawData = AnmFunctionHeader2.pack(frame)
        fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
        currentOffset += rawData.length
        var baseOffset = currentOffset
        currentOffset += 8 * frameExpr.body.body.length
        frameExpr.body.body.forEach((callExpr, index) => {
          assert(callExpr.type === 'ExpressionStatement')
          assert(callExpr.expression.type === 'CallExpression')
          var call = {
            group: 0,
            id: 0,
            dataCount: callExpr.expression.arguments.length / 2
          }
          call.group = parseInt(callExpr.expression.callee.name.substr(1, 2), 16)
          call.id = parseInt(callExpr.expression.callee.name.substr(4), 16)
          rawData = AnmCommand.pack(call)
          fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
          currentOffset += rawData.length

          rawData = _.uint32le(1).pack([currentOffset - baseOffset])
          fs.writeSync(outAnm, rawData, 0, rawData.length, baseOffset + 8 * index)

          callExpr.expression.arguments.forEach((argumentExpr) => {
            if (argumentExpr.type === 'Literal') {
              rawData = _.uint32le(1).pack([argumentExpr.value])
              fs.writeSync(outAnm, rawData, 0, rawData.length, currentOffset)
              currentOffset += rawData.length
            }
          })
        })
        rawData = AnmFunctionHeader.pack(frame)
        fs.writeSync(outAnm, rawData, 0, rawData.length, state.offset + 0x10 + 8 * index)
      })
      var rawData = AnmEntryHeader.pack(anmentryheader)
      fs.writeSync(outAnm, rawData, 0, rawData.length, entryBase)
      rawData = common.CommonTableEntry.pack(state)
      fs.writeSync(outAnm, rawData, 0, rawData.length, 0x10 + 8 * index)
    })
  } catch (e) {
    console.log('error on file:', currentFile)
    console.log(e)
  }
}
module.exports = {
  pack: pack,
  unpackFile: unpackFile,
  unpack: unpack
}
